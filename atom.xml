<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mu00&#39;s Blog</title>
  <icon>https://mu00.jusot.com/favicon.png</icon>
  <subtitle>IHPATFW</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mu00.jusot.com/"/>
  <updated>2020-08-03T14:50:54.646Z</updated>
  <id>https://mu00.jusot.com/</id>
  
  <author>
    <name>Mu001999</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一点点复制移动</title>
    <link href="https://mu00.jusot.com/2020/03/21/%E4%B8%80%E7%82%B9%E7%82%B9%E5%A4%8D%E5%88%B6%E7%A7%BB%E5%8A%A8/"/>
    <id>https://mu00.jusot.com/2020/03/21/%E4%B8%80%E7%82%B9%E7%82%B9%E5%A4%8D%E5%88%B6%E7%A7%BB%E5%8A%A8/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-08-03T14:50:54.646Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span> &#123;</span><br>    Test() = <span class="hljs-keyword">default</span>;<br>    Test(<span class="hljs-keyword">const</span> Test&amp;) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;copy ctor&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    Test(Test&amp;&amp;) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;move ctor&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(Test t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t1;<br>    <span class="hljs-keyword">auto</span> t2 = test(t1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也算是日经问题了, 但我太弱了, 还是得记一下, 首先我们看上面的代码, 输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">copy ctor<br>move ctor<br></code></pre></td></tr></table></figure><p>第一个 <code>copy ctor</code> 很好理解, 那么第二个是哪里的呢? 答案是 test 返回的时候, 首先因为 t 是形参, 所以在 return 这里不满足 <a href="https://en.cppreference.com/w/cpp/language/copy_elision">copy elision</a> 的要求, 所以这里不会进行优化, 故需要调用一次构造函数, 比如我们把 <code>auto t2 = test(t1)</code> 修改为 <code>test(t1)</code>, 会发现输出没有改变</p><p>那为什么 <code>return t</code> 的时候调用的是移动构造函数而不是复制构造呢, 参见<a href="http://eel.is/c++draft/class.copy.elision#3">class.copy.elision #3</a>, 简单点说就是在需要复制语义时, 如果条件允许, 可以使用移动操作, 那么我们把移动构造删掉应该可以使用复制构造了吧, 那就改成下边这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span> &#123;</span><br>    Test() = <span class="hljs-keyword">default</span>;<br>    Test(<span class="hljs-keyword">const</span> Test&amp;) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;copy ctor&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    Test(Test&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(Test t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t1;<br>    <span class="hljs-keyword">auto</span> t2 = test(t1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码用 C++17 是可以编译的, 并且打印结果和预期一样, 是两个 copy ctor, 但是在 C++17 之前(以及 C++11 之后)编译是通不过的, 这又是为什么呢?</p><p>答案是在<a href="https://en.cppreference.com/w/cpp/language/copy_initialization">复制初始化</a>的时候, 如果初始化器是一个右值, 重载决议的时候会选择移动构造, 而如果移动构造被显式弃置(delete)了, 就会报错, 但是在 C++17 之后, 因为 copy elision 是强制的, 所以这里不需要调用移动构造, 从而也就不会报错, 比如我们还是把 <code>auto t2 = test(t1)</code> 改成 <code>test(t1)</code>, 在 C++17 之前也可以通过编译了</p><p>但是除此之外还有一个问题, 当我们把显式弃置移动构造的语句删掉时, 变成下边这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span> &#123;</span><br>    Test() = <span class="hljs-keyword">default</span>;<br>    Test(<span class="hljs-keyword">const</span> Test&amp;) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;copy ctor&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(Test t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t1;<br>    <span class="hljs-keyword">auto</span> t2 = test(t1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是可以正常通过编译的, 尽管当用户声明了复制构造函数之后, 移动构造函数不会被隐式声明, 但是重载决议会忽略掉这件事, 因为会阻止从右值复制初始化, 参见<a href="https://en.cppreference.com/w/cpp/language/move_constructor">移动构造函数一节</a>中所述:</p><blockquote><p>The deleted implicitly-declared move constructor is ignored by overload resolution (otherwise it would prevent copy-initialization from rvalue).</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>扯 C++ 里的 Lambda</title>
    <link href="https://mu00.jusot.com/2020/03/17/%E6%89%AF%20C++%20%E9%87%8C%E7%9A%84%20Lambda/"/>
    <id>https://mu00.jusot.com/2020/03/17/%E6%89%AF%20C++%20%E9%87%8C%E7%9A%84%20Lambda/</id>
    <published>2020-03-16T16:00:00.000Z</published>
    <updated>2020-08-03T14:50:24.697Z</updated>
    
    <content type="html"><![CDATA[<p>之前写(抄) parsec 的时候, 在重载 <code>operator&gt;&gt;</code> 的时候, <code>operator&gt;&gt;</code> 需要接收一个 lambda, 之后返回一个 <code>Component&lt;R&gt;</code>, 其中 R 是接收 lambda 的返回值类型, 所以就要搞到 lambda 对应的函数类型</p><p>在一开始我是直接用 <code>std::function</code> 做的, 但是众所周知, 下面这样的写法是匹配不了的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ...Args&gt;<br>ParsecComponent&lt;R&gt; <span class="hljs-keyword">operator</span>&gt;&gt;(<span class="hljs-built_in">std</span>::function&lt;R(Args...)&gt; callback) &#123;<br>    ParsecComponent&lt;R&gt; component;<br>    ...<br>    <span class="hljs-keyword">return</span> component;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 lambda 表达式到 std::function 要进行类型转换, 毕竟是两个类型, 所以指明 std::function 的模板实参的时候才能进行 lambda -&gt; std::function 的隐式转换, 不过一开始为了偷懒, 而且我只需要拿到 lambda 的返回值类型, 就这样写了:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;<br><span class="hljs-keyword">auto</span> <span class="hljs-keyword">operator</span>&gt;&gt;(Func &amp;&amp;callback) &#123;<br>    <span class="hljs-keyword">using</span> NewResult = <span class="hljs-keyword">typename</span> <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::function(callback))::result_type;<br>    ParsecComponent&lt;NewResult&gt; component;<br>    ...<br>    <span class="hljs-keyword">return</span> component;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以说 <code>auto</code> 这种东西还真是好用啊, 类型还可以拖延到函数体里做(</p><p>这样做总归有种脱裤子放屁的感觉, 那么怎么不通过 std::function 就能拿到 lambda 表达式对应的函数类型呢?</p><p>众所周知, 每一个 lambda 表达式的类型都是不一样的, 比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Func &amp;&amp;f)</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(Func).name() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    print([]()&#123;&#125;);<br>    print([]()&#123;&#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我这里输出的结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">Z4mainE3$_0<br>Z4mainE3$_1<br></code></pre></td></tr></table></figure><p>毕竟如果要每个定义相同的 lambda 的类型相同是不现实而而且没有必要的, 何况还有闭包捕获之类的复杂性需要考虑, 但是众所周知, lambda 返回的是一个对象, 也即它的类型重载了 <code>operator()</code>, 而 <code>operator()</code> 又是一个函数, 那么我们不久可以通过推导其重载的 <code>operator()</code> 函数类型拿到 lambda 对应的函数类型了吗(</p><p>所以这件事情很清晰明了了, 我们只需要拿到 lambda 表达式产生的匿名类型, 然后根据类成员函数寻址到它的 <code>operator()</code>, 然后推导出 <code>operator()</code> 的函数签名就可以了!</p><p>那就划分成三步吧</p><h2 id="一-得到-lambda-对应的匿名类类型"><a href="#一-得到-lambda-对应的匿名类类型" class="headerlink" title="一, 得到 lambda 对应的匿名类类型"></a>一, 得到 lambda 对应的匿名类类型</h2><p>这一步是很简单的, 因为只要模板实参自动推导一下就出来了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Func &amp;&amp;lambda)</span></span>;<br></code></pre></td></tr></table></figure><p>那现在这个 Func 就是我们需要的类型</p><h2 id="二-推导-Func-重载的-operator-函数签名"><a href="#二-推导-Func-重载的-operator-函数签名" class="headerlink" title="二, 推导 Func 重载的 operator() 函数签名"></a>二, 推导 Func 重载的 <code>operator()</code> 函数签名</h2><p>因为当前我们只有一个 Func 类型, 但是如果要获取 <code>operator()</code> 的签名的话, 我们还需要对 <code>operator()</code> 的类型做一个特化, 比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lambda_traits</span>;</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ClassType, <span class="hljs-keyword">typename</span> ...Args&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lambda_traits</span>&lt;R(ClassType::*)(Args...) const&gt; &#123;</span><br>    <span class="hljs-keyword">using</span> result_type = R;<br>    <span class="hljs-keyword">using</span> args_type = <span class="hljs-built_in">std</span>::tuple&lt;Args...&gt;;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">size_t</span> index&gt;<br>    <span class="hljs-keyword">using</span> arg_type_at = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">tuple_element_t</span>&lt;index, args_type&gt;;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> arity = <span class="hljs-keyword">sizeof</span>...(Args);<br>&#125;;<br></code></pre></td></tr></table></figure><p>很简单对吧, 只需要对类的成员函数的类型做一个特化就好了</p><p>其实这个时候已经可以用了, 比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func,<br>    <span class="hljs-keyword">typename</span> R = <span class="hljs-keyword">typename</span> lambda_traits&lt;<span class="hljs-keyword">decltype</span>(&amp;Func::<span class="hljs-keyword">operator</span>())&gt;::result_type&gt;<br><span class="hljs-keyword">void</span> foo(Func &amp;&amp;lambda);<br></code></pre></td></tr></table></figure><h2 id="三-包装一下"><a href="#三-包装一下" class="headerlink" title="三, 包装一下"></a>三, 包装一下</h2><p>其实可以看到第二步的时候已经可以用了, 那么我们只需要把调用的过程包装一下, 但是由于我们拿到的是一个 Func, 所以需要把之前的 <code>lambda_traits</code> 变成基类, 然后另 Func 实例化的模板类继承它就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lambda_traits_base</span>;</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ClassType, <span class="hljs-keyword">typename</span> ...Args&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lambda_traits_base</span>&lt;R(ClassType::*)(Args...) const&gt; &#123;</span><br>    <span class="hljs-keyword">using</span> result_type = R;<br>    <span class="hljs-keyword">using</span> args_type = <span class="hljs-built_in">std</span>::tuple&lt;Args...&gt;;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">size_t</span> index&gt;<br>    <span class="hljs-keyword">using</span> arg_type_at = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">tuple_element_t</span>&lt;index, args_type&gt;;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> arity = <span class="hljs-keyword">sizeof</span>...(Args);<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lambda_traits</span> :</span> lambda_traits_base&lt;<span class="hljs-keyword">decltype</span>(&amp;Func::<span class="hljs-keyword">operator</span>())&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><p>支持 C++17 的 lambda 现在是没有问题了, 那么有人要问了, C++20 的 lambda 是支持模板 operator() 的, 这个显然是不支持的啊, 是垃圾</p><p>那就来接轨一哈 20 吧, 反正接轨了之后是不影响 17 的 lambda 推导的</p><hr><p>支持 template operator() 的 lambda 顾名思义就是长这样子的啦:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> foo = []&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ...Args&gt;(Args...) -&gt; T &#123; <span class="hljs-keyword">return</span> T(); &#125;;<br>foo.<span class="hljs-keyword">operator</span>()&lt;...&gt;(...);<br></code></pre></td></tr></table></figure><p>可以看出来(目前)如果要调用这个 lambda 的话, 我们需要显式地指明模板的实参, 所以在推导的时候, 模板实参的信息也是要提供的, 那么只需要简单地修改一下我们的 lambda_traits:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func, <span class="hljs-keyword">typename</span> ...Args&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lambda_traits</span> :</span> lambda_traits_base&lt;<span class="hljs-keyword">decltype</span>(&amp;Func::<span class="hljs-keyword">template</span> <span class="hljs-keyword">operator</span>()&lt;Args...&gt;)&gt; &#123;&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lambda_traits</span> :</span> lambda_traits_base&lt;<span class="hljs-keyword">decltype</span>(&amp;Func::<span class="hljs-keyword">operator</span>())&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><p>这样一来就可以了, 不过还有一种特殊情况, 比如说我们有一个这样类似提供了 template operator() 的类:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Args&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在获取他无模板实参的 operator() 时, 我们只能通过 <code>&amp;Foo::template operator()&lt;&gt;</code> 而不能写 <code>&amp;Foo::operator()</code>, 当然这也是显而易见的, 不过如果我们的 lambda 支持的 template operator() 能够接收无实参的实例化的话, 就会导致前边的 lambda_traits 失效, 所以我们需要在模板实参 Args 为空的时候判断一下要取 <code>operator()</code> 还是 <code>template operator()&lt;&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">void_t</span>&lt;&gt;&gt;<br>struct call_which &#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">decltype</span>(&amp;T::<span class="hljs-keyword">operator</span>());<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">call_which</span>&lt;T, std::void_t&lt;decltype(&amp;T::template operator()&lt;&gt;)&gt;&gt; &#123;</span><br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">decltype</span>(&amp;T::<span class="hljs-keyword">template</span> <span class="hljs-keyword">operator</span>()&lt;&gt;);<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">call_which_t</span> = <span class="hljs-keyword">typename</span> call_which&lt;T&gt;::type;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ...Args&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lambda_traits</span> :</span> lambda&lt;<span class="hljs-keyword">decltype</span>(&amp;T::<span class="hljs-keyword">template</span> <span class="hljs-keyword">operator</span>()&lt;Args...&gt;)&gt; &#123;&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lambda_traits</span>&lt;T&gt; :</span> lambda&lt;<span class="hljs-keyword">call_which_t</span>&lt;T&gt;&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><p>通过 <code>void_t</code> 判断了一下是不是具有 <code>template operator()&lt;&gt;</code> 就可以了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前写(抄) parsec 的时候, 在重载 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 的时候, &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 需要接收一个 lambda, 之后返回一个 &lt;code&gt;Component&amp;lt;R&amp;gt;&lt;/c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C++ 实现 Parsec</title>
    <link href="https://mu00.jusot.com/2020/03/15/C++%20%E5%AE%9E%E7%8E%B0%20Parsec/"/>
    <id>https://mu00.jusot.com/2020/03/15/C++%20%E5%AE%9E%E7%8E%B0%20Parsec/</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2020-08-03T14:49:44.702Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间看到了梨梨喵聚聚写的<a href="https://zhuanlan.zhihu.com/p/25411428">Parser Combinator 在 C++ 里的 DSL</a>, 感觉好厉害, 正好毕设里要写一部分前端, 昨天又把这篇文章看了一遍, 想着我也要用这么酷炫的东西来参与一下毕设, 于是今天仿了一个, 不过由于电脑屏幕太小(理由), 看不懂梨梨喵聚聚的代码, 只好照着文章里的理念自己试着实现一下, 类的设计应该差不多, 不过具体的实现应该鶸了很多, 代码在<a href="https://github.com/MU001999/parsec">parsec</a>, 目前还不支持左递归和垃圾回收(</p><p>先上一个加减的小例子吧:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Parsec&lt;<span class="hljs-keyword">char</span>&gt; Decimal;<br>Parsec&lt;<span class="hljs-built_in">string</span>&gt; Number;<br>Parsec&lt;<span class="hljs-keyword">int</span>&gt; Primary, Additive, Additive_;<br><br><span class="hljs-comment">// Decimal := &#x27;0&#x27; | ... | &#x27;9&#x27;</span><br>Decimal = (<span class="hljs-string">&#x27;0&#x27;</span>_T | <span class="hljs-string">&#x27;1&#x27;</span>_T | <span class="hljs-string">&#x27;2&#x27;</span>_T | <span class="hljs-string">&#x27;3&#x27;</span>_T | <span class="hljs-string">&#x27;4&#x27;</span>_T | <span class="hljs-string">&#x27;5&#x27;</span>_T | <span class="hljs-string">&#x27;6&#x27;</span>_T | <span class="hljs-string">&#x27;7&#x27;</span>_T | <span class="hljs-string">&#x27;8&#x27;</span>_T | <span class="hljs-string">&#x27;9&#x27;</span>_T );<br><br><span class="hljs-comment">// Number := Decimal Number | Decimal</span><br>Number =<br>    (Decimal + Number &gt;&gt;<br>        [](<span class="hljs-keyword">char</span> decimal, <span class="hljs-built_in">string</span> number) &#123;<br>            <span class="hljs-keyword">return</span> decimal + number;<br>        &#125;) |<br>    (Decimal &gt;&gt;<br>        [](<span class="hljs-keyword">char</span> decimal) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>() + decimal;<br>        &#125;);<br><br><span class="hljs-comment">// Primary := Number</span><br>Primary = Number &gt;&gt; [](<span class="hljs-built_in">string</span> number) &#123;<br>    <span class="hljs-keyword">return</span> stoi(number);<br>&#125;;<br><br><span class="hljs-comment">// Additive := Primary Additive_ | Primary</span><br><span class="hljs-comment">// Additive_ := + Additive | - Additive</span><br>Additive =<br>    (Primary + Additive_ &gt;&gt;<br>        [](<span class="hljs-keyword">int</span> primary, <span class="hljs-keyword">int</span> additive) &#123;<br>            <span class="hljs-keyword">return</span> primary + additive;<br>        &#125;) |<br>    (Primary &gt;&gt; [](<span class="hljs-keyword">int</span> primary) &#123;<br>        <span class="hljs-keyword">return</span> primary;<br>    &#125;);<br>Additive_ = ((<span class="hljs-string">&#x27;+&#x27;</span>_T | <span class="hljs-string">&#x27;-&#x27;</span>_T) + Additive &gt;&gt; [](<span class="hljs-keyword">char</span> op, <span class="hljs-keyword">int</span> additive) &#123;<br>    <span class="hljs-keyword">return</span> (op == <span class="hljs-string">&#x27;+&#x27;</span> ? additive : -additive);<br>&#125;);<br><br><span class="hljs-built_in">cout</span> &lt;&lt; Additive(<span class="hljs-string">&quot;1+2+3&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>例子是改的梨梨瞄聚聚的, 因为不支持左递归, 只能手动提取公因子了(</p><p>和梨梨瞄聚聚重复的原理部分就不说了, 想知道的可以看一下梨梨瞄聚聚的那篇文章, 说一下不一样的地方吧, 我的实现里的类型笛卡尔乘积的结果使用 std::tuple&lt;Ts…&gt; 表示的, 类型的和的结果用 std::variant&lt;Ts…&gt; 表示, 当返回值的类型可能有多类型的时候就可以使形参的类型为 std::variant&lt;Ts…&gt;, 保证类型安全的同时还能接收多个类型的结果, 同样可以令组合子返回的是一个 tuple 类型, 可以继续和其它类型相乘或者相加, 后边就可以简化实现.</p><p>写了好几个小时, 虽然代码不多, 但是模板多起来密度太大真的眼花缭乱, 希望之后能支持一下左递归之类的操作吧, 毕竟还要拿来写毕设, 边用边改吧(</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一段时间看到了梨梨喵聚聚写的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25411428&quot;&gt;Parser Combinator 在 C++ 里的 DSL&lt;/a&gt;, 感觉好厉害, 正好毕设里要写一部分前端, 昨天又把这篇文章看了一遍, 想着我
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>模板实现编译时冒泡排序</title>
    <link href="https://mu00.jusot.com/2020/03/09/%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E6%97%B6%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://mu00.jusot.com/2020/03/09/%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E6%97%B6%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</id>
    <published>2020-03-08T16:00:00.000Z</published>
    <updated>2020-08-03T14:49:13.994Z</updated>
    
    <content type="html"><![CDATA[<p>看到特首写了个编译时的归并，感觉挺好玩，写了个冒泡试试，第一次用模板写这种东西，见笑了（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> ...vals&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vals</span> &#123;</span>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ValueAt</span>;</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> val0, <span class="hljs-keyword">int</span> ...vals&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ValueAt</span>&lt;i, Vals&lt;val0, vals...&gt;&gt;</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> val = ValueAt&lt;i - <span class="hljs-number">1</span>, Vals&lt;vals...&gt;&gt;::val;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> val0, <span class="hljs-keyword">int</span> ...vals&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ValueAt</span>&lt;0, Vals&lt;val0, vals...&gt;&gt;</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> val = val0;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Combine</span>;</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> ...vals1, <span class="hljs-keyword">int</span> ...vals2&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Combine</span>&lt;Vals&lt;vals1...&gt;, Vals&lt;vals2...&gt;&gt;</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">using</span> type = Vals&lt;vals1..., vals2...&gt;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwapValue</span>;</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> val, <span class="hljs-keyword">int</span> ...vals&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwapValue</span>&lt;i, Vals&lt;val, vals...&gt;&gt;</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> Combine&lt;Vals&lt;val&gt;, <span class="hljs-keyword">typename</span> SwapValue&lt;i - <span class="hljs-number">1</span>, Vals&lt;vals...&gt;&gt;::type&gt;::type;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> val1, <span class="hljs-keyword">int</span> val2, <span class="hljs-keyword">int</span> ...vals&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwapValue</span>&lt;0, Vals&lt;val1, val2, vals...&gt;&gt;</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> Combine&lt;Vals&lt;val2&gt;, <span class="hljs-keyword">typename</span> Combine&lt;Vals&lt;val1&gt;, Vals&lt;vals...&gt;&gt;::type&gt;::type;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> val1, <span class="hljs-keyword">int</span> val2&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwapValue</span>&lt;0, Vals&lt;val1, val2&gt;&gt;</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">using</span> type = Vals&lt;val2, val1&gt;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BubbleSort</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> <span class="hljs-keyword">conditional_t</span>&lt;(ValueAt&lt;j - <span class="hljs-number">1</span>, T&gt;::val &gt; ValueAt&lt;j, T&gt;::val),<br>        BubbleSort&lt;i, j + <span class="hljs-number">1</span>, <span class="hljs-keyword">typename</span> SwapValue&lt;j - <span class="hljs-number">1</span>, T&gt;::type&gt;,<br>        BubbleSort&lt;i, j + <span class="hljs-number">1</span>, T&gt;&gt;::type;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> val&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BubbleSort</span>&lt;1, 1, Vals&lt;val&gt;&gt;</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">using</span> type = Vals&lt;val&gt;;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> ...vals&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BubbleSort</span>&lt;sizeof...(vals), j, Vals&lt;vals...&gt;&gt;</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">using</span> type = Vals&lt;vals...&gt;;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> ...vals&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BubbleSort</span>&lt;i, sizeof...(vals), Vals&lt;vals...&gt;&gt;</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> BubbleSort&lt;i + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, Vals&lt;vals...&gt;&gt;::type;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sort</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> BubbleSort&lt;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, T&gt;::type;<br>&#125;;<br><br>template&lt;int ...vals&gt; void print(Vals&lt;vals...&gt;)<br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> vs = &#123; vals... &#125;;<br>    copy(begin(vs), end(vs), ostream_iterator&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">cout</span>, <span class="hljs-string">&quot; &quot;</span>));<br>    <span class="hljs-built_in">endl</span>(<span class="hljs-built_in">cout</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    print(Sort&lt;Vals&lt;<span class="hljs-number">1</span>&gt;&gt;::type());<br>    print(Sort&lt;Vals&lt;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&gt;&gt;::type());<br>    print(Sort&lt;Vals&lt;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>&gt;&gt;::type());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码本身很简单，就是冒泡的思路，递归 j 的终止条件应该还可以优化一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到特首写了个编译时的归并，感觉挺好玩，写了个冒泡试试，第一次用模板写这种东西，见笑了（&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>通过 call-cc 给 Ice 实现 Coroutine</title>
    <link href="https://mu00.jusot.com/2020/02/24/%E9%80%9A%E8%BF%87%20call-cc%20%E7%BB%99%20Ice%20%E5%AE%9E%E7%8E%B0%20Coroutine/"/>
    <id>https://mu00.jusot.com/2020/02/24/%E9%80%9A%E8%BF%87%20call-cc%20%E7%BB%99%20Ice%20%E5%AE%9E%E7%8E%B0%20Coroutine/</id>
    <published>2020-02-23T16:00:00.000Z</published>
    <updated>2020-08-03T14:48:40.405Z</updated>
    
    <content type="html"><![CDATA[<p>前两天给 Ice 加了 call/cc, 为此还重构了一波, 实现 call/cc 还是因为看了轮子哥的大专系列(</p><p>里边说提供 continuation 语言实现 Coroutine 起来很轻松, 后来又查了一些资料, 都说 continuation 表达能力很强, 就实现了一手, 调用方式完全等同 call/cc, 既然是看 Coroutine 才要实现 call/cc, 那实现了之后当然要用 call/cc 实现一手 Coroutine 了(</p><p>不过这个 Coroutine 比较简陋, 只提供 create, resume, yield, destroy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs plain">coroutine: (@() &#123;<br>    @funcs: [];<br>    @conts: [];<br>    @deletes: [];<br>    @co_cont: none;<br><br>    @create(func) &#123;<br>        if deletes.empty() &#123;<br>            @id: funcs.size();<br>            funcs.push(func);<br>            conts.push(none);<br>            return id;<br>        &#125; else &#123;<br>            @id: deletes.pop();<br>            funcs[id]: func;<br>            conts[id]: none;<br>            return id;<br>        &#125;<br>    &#125;<br><br>    @resume(id) &#123;<br>        if conts[id] &#x3D; none &#123;<br>            conts[id]: call_with_current_continuation(@(cont) &#123;<br>                co_cont: cont;<br>                funcs[id]();<br>            &#125;);<br>        &#125; else &#123;<br>            conts[id]: call_with_current_continuation(@(cont) &#123;<br>                co_cont: cont;<br>                conts[id](none);<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    @yield() &#123;<br>        call_with_current_continuation(co_cont);<br>    &#125;<br><br>    @destroy(id) &#123;<br>        funcs[id]: conts[id]: none;<br>        deletes.push(id);<br>    &#125;<br><br>    return @() &#123;&#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>测试一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">@foo() &#123;<br>    @i: 0;<br>    while i &lt; 5 &#123;<br>        println(i: i + 1);<br>        coroutine.yield();<br>    &#125;<br>&#125;<br><br>@id1: coroutine.create(foo);<br>@id2: coroutine.create(foo);<br><br>@i: 0;<br>while i &lt; 5 &#123;<br>    coroutine.resume(id1);<br>    coroutine.resume(id2);<br>    i: i + 1;<br>&#125;<br><br>coroutine.destroy(id1);<br>coroutine.destroy(id2);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br>1<br>2<br>2<br>3<br>3<br>4<br>4<br>5<br>5<br></code></pre></td></tr></table></figure><p>里边唯一我觉得有点意思的地方是 resume 里, 直接在 lambda 里将当前的 continuation 绑定到 co_cont 上, 这样用户 create 的时候传入的函数就只需要调用 yield 了</p><p>可惜除了 vsc 都没有 Ice 的高亮(</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两天给 Ice 加了 call/cc, 为此还重构了一波, 实现 call/cc 还是因为看了轮子哥的大专系列(&lt;/p&gt;
&lt;p&gt;里边说提供 continuation 语言实现 Coroutine 起来很轻松, 后来又查了一些资料, 都说 continuation 表达能力
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C++ 的 Copy Elision 导致的奇怪问题</title>
    <link href="https://mu00.jusot.com/2019/10/02/C++%20%E7%9A%84%20Copy%20Elision%20%E5%AF%BC%E8%87%B4%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/"/>
    <id>https://mu00.jusot.com/2019/10/02/C++%20%E7%9A%84%20Copy%20Elision%20%E5%AF%BC%E8%87%B4%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/</id>
    <published>2019-10-01T16:00:00.000Z</published>
    <updated>2020-08-03T14:48:10.819Z</updated>
    
    <content type="html"><![CDATA[<p>最近写设计模式作业的时候, 有一个作业是实现<a href="https://en.wikipedia.org/wiki/Decorator_pattern">装饰器模式 (Decorator Pattern)</a>, 由于我不会 Java, 所以只能用 C++ 来实现 :)</p><p>在这个背景下, 会有简单(表意)的几个类, 如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~Base() = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">inline</span> Base::~Base() &#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedA</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    DerivedA(<span class="hljs-keyword">int</span> data) : data_(data) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getData</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> data_;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> data_;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedB</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    DerivedB(<span class="hljs-keyword">const</span> Base &amp;pre) : pre_(pre) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getData</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> pre_.getData() + <span class="hljs-number">1</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">const</span> Base &amp;pre_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>简单来写就是上面这样, DerivedB 类型的对象可以接收以 Base 类作为基类的对象引用并且绑定到成员 pre_ 上, 在调用 getData 方法时会调用 pre_ 绑定的对象的 getData 方法, 并在其结果的基础上运算后返回</p><p>而这样的设计会导致一种很直觉的使用方法, 如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">cout</span> &lt;&lt; DerivedB(DerivedB(DerivedA(<span class="hljs-number">10</span>))).getData() &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>也即嵌套对象, 实现 getData 的多次调用</p><p>但是这样的使用方式会造成与预期不符的结果出现, 如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">~&gt; g++ -std=c++17 test.cpp -o test<br>~&gt; ./test<br>11<br>~&gt; clang++ -std=c++17 test.cpp -o test<br>~&gt; ./test<br>11<br></code></pre></td></tr></table></figure><p>会发现结果表明, 只有一个 DerivedB 类型的对象被构造了出来, <a href="https://en.cppreference.com/w/cpp/language/copy_elision">cppreference 的 copy elision 章节</a>中的解释部分有提到:</p><blockquote><p>Under the following circumstances, the compilers are required to omit the copy and move construction of class objects, <strong>even if the copy/move constructor and the destructor have observable side-effects</strong>. The objects are constructed directly into the storage where they would otherwise be copied/moved to. <strong>The copy/move constructors need not be present or accessible</strong>, as the language rules ensure that no copy/move operation takes place, even conceptually:</p></blockquote><blockquote><ul><li>In a return statement, when the operand is a prvalue of the same class type (ignoring cv-qualification) as the function return type:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">T <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> T();<br>&#125;<br><br>f(); <span class="hljs-comment">// only one call to default constructor of T</span><br></code></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>In the initialization of a variable, when the initializer expression is a prvalue of the same class type (ignoring cv-qualification) as the variable type:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">T x = T(T(f())); <span class="hljs-comment">// only one call to default constructor of T, to initialize x</span><br></code></pre></td></tr></table></figure></li></ul></blockquote><p>上面这句被我标粗的文字可以看到, 即使拷贝/移动构造有副作用, 依然只构造一次, 甚至不需要有拷贝/移动构造函数</p><p>可以在类中添加如下定义:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedB</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// new additions</span><br>    DerivedB(<span class="hljs-keyword">const</span> DerivedB &amp;) = <span class="hljs-keyword">delete</span>;<br>    DerivedB(DerivedB &amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    DerivedB(<span class="hljs-keyword">const</span> Base &amp;pre) : pre_(pre) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getData</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> pre_.getData() + <span class="hljs-number">1</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">const</span> Base &amp;pre_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>会发现依然可以通过编译并且运行结果与之前相同 ( 因为在 C++17 中 Copy Elision 已经不再是可选项 ), 但是在 C++17 之前如果 delete 了这两个拷贝/移动构造函数, 会导致无法通过编译, 尽管有可以匹配 const Base &amp; 类型的构造函数, 也依然不可以:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">test.cpp:45:13: error: functional-style cast from &#x27;DerivedB&#x27;<br>      to &#x27;DerivedB&#x27; uses deleted function<br>    cout &lt;&lt; DerivedB(DerivedB(DerivedA(10))).getData...<br>            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>test.cpp:31:5: note: candidate constructor has been<br>      explicitly deleted<br>    DerivedB(DerivedB &amp;&amp;) = delete;<br>    ^<br>test.cpp:30:5: note: candidate constructor has been<br>      explicitly deleted<br>    DerivedB(const DerivedB &amp;) = delete;<br>    ^<br>test.cpp:33:5: note: candidate constructor<br>    DerivedB(const Base &amp;pre) : pre_(pre) &#123;&#125;<br>    ^<br>1 error generated.<br></code></pre></td></tr></table></figure><p>感谢 <a href="https://www.zhihu.com/people/lei-yu-10-27">禽牙</a> 在评论中提出, 事实上如果我们在尚未 delete 那两个构造函数通过如下的方式调用, 也依然不可行:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DerivedA <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">DerivedB <span class="hljs-title">b1</span><span class="hljs-params">(a)</span></span>;<br><span class="hljs-function">DerivedB <span class="hljs-title">b2</span><span class="hljs-params">(b1)</span></span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; b2.getData() &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>结果依然是 11, 这是因为重载决议后其实我们调用的是匹配类型为 <code>const DerivedB &amp;</code> 的构造函数, 同样如果我们约定在代码中都是用这样的方式编写程序, 我们就可以获得一种解决方式, 编写匹配类型的构造函数, 如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br>DerivedB(<span class="hljs-keyword">const</span> DerivedB &amp;pre) : pre_(pre) &#123;&#125;<br>...<br></code></pre></td></tr></table></figure><p>再通过声明中间变量的方式调用就可以获得正确结果, 但是通过纯右值的形式依然不行:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br><span class="hljs-function">DerivedA <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">DerivedB <span class="hljs-title">b1</span><span class="hljs-params">(a)</span></span>;<br><span class="hljs-function">DerivedB <span class="hljs-title">b2</span><span class="hljs-params">(b1)</span></span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; b2.getData() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">// print 12</span><br>...<br><span class="hljs-built_in">cout</span> &lt;&lt; DerivedB(DerivedB(DerivedA(<span class="hljs-number">10</span>))).getData() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">// print 11</span><br>...<br></code></pre></td></tr></table></figure><p>所以如何才能在这种设计下通过这种方式正常使用呢?</p><p>一种可以显著增加代码程度的方式是, 手动添加强制转换:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">cout</span> &lt;&lt; DerivedB(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> Base &amp;&gt;(DerivedB(DerivedA(<span class="hljs-number">10</span>)))).getData() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; DerivedB((<span class="hljs-keyword">const</span> Base &amp;)(DerivedB(DerivedA(<span class="hljs-number">10</span>)))).getData() &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// C-style</span><br></code></pre></td></tr></table></figure><p>当然这种方式其实还是可以接受的</p><p>还有一种可以不会增加太多冗余代码的方式是在构造函数里增加一个冗余参数, 区分开就可以了, 比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedB</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    DerivedB(<span class="hljs-keyword">const</span> Base &amp;pre, <span class="hljs-keyword">int</span>) : pre_(pre) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getData</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> pre_.getData() + <span class="hljs-number">1</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">const</span> Base &amp;pre_;<br>&#125;;<br>...<br><span class="hljs-built_in">cout</span> &lt;&lt; DerivedB(DerivedB(DerivedA(<span class="hljs-number">10</span>), <span class="hljs-number">0</span>), <span class="hljs-number">0</span>).getData() &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>当然以上两种都是在不涉及模板的情况下完成的, 但是都会对调用的方便性产生影响</p><p>还有一种不会更改调用方式, 通过模板区分嵌套的相同类型的方式, 感谢 <a href="https://www.zhihu.com/people/91khr">91khr</a> 提供:</p><p>首先先将 DerivedB 变成一个类模板, 之后添加<a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">模板推导指引</a>来实现嵌套区分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">int</span> Lv&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedB</span>;</span><br>...<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Ty&gt; DerivedB(Ty) -&gt; DerivedB&lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">int</span> Lv&gt; DerivedB(DerivedB&lt;Lv&gt;) -&gt; DerivedB&lt;Lv + <span class="hljs-number">1</span>&gt;;<br>...<br><span class="hljs-built_in">cout</span> &lt;&lt; DerivedB(DerivedB(DerivedA(<span class="hljs-number">10</span>))).getData() &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>在此条件之下, 结果与预期相同, 完美解决问题:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">~&gt; clang++ -std=c++17 test.cpp -o test<br>~&gt; ./test<br>12<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近写设计模式作业的时候, 有一个作业是实现&lt;a href=&quot;https://en.wikipedia.org/wiki/Decorator_pattern&quot;&gt;装饰器模式 (Decorator Pattern)&lt;/a&gt;, 由于我不会 Java, 所以只能用 C++ 来实现 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>百度实习面试反思</title>
    <link href="https://mu00.jusot.com/2019/06/07/%E7%99%BE%E5%BA%A6%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E5%8F%8D%E6%80%9D/"/>
    <id>https://mu00.jusot.com/2019/06/07/%E7%99%BE%E5%BA%A6%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E5%8F%8D%E6%80%9D/</id>
    <published>2019-06-06T16:00:00.000Z</published>
    <updated>2020-08-03T14:55:25.470Z</updated>
    
    <content type="html"><![CDATA[<p>首先是在实习僧上投的简历，第一周因为手机问题没有接到电话，第二周才打过去约到了第二天上午十点面试。</p><p>第一次去百度这样的大公司面试，讲真还是很紧张的，提前快一个小时就到地方了，然后因为那地儿实在太堵了，一面的面试官堵在路上了，所以等到十一点多才正式开始面试，结果一天就面了三面……确实有点累，面试完手机还没电自动关机了，身上也没有现金，只有个公交卡，靠着我顽强的生存欲望找到了地铁站才回到学校:)，趁着脑袋里还能记着住点今天面试的东西，赶紧总结一下，不敢说是面经，只能算是记录再加上自己的一些反思，不过还是学到了很多东西，也认识到自己很多的不足，还是蛮感谢遇到的三位面试官的:)。</p><h4 id="面试职位：知识图谱部，知识图谱检索架构研发实习生"><a href="#面试职位：知识图谱部，知识图谱检索架构研发实习生" class="headerlink" title="面试职位：知识图谱部，知识图谱检索架构研发实习生"></a>面试职位：知识图谱部，知识图谱检索架构研发实习生</h4><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>【一面】</p><ol><li><p>先问的关于简历上贴的项目的问题比较多</p><p> 比如问了我一些编译原理实际能够应用在哪些场景，解决哪些有价值问题，另外让我在纸上设计了一个符号表的结构，基本上都是从项目里衍生出来的问题</p></li><li><p>计算机网络分层、TCP/IP协议栈的主要协议</p></li><li><p>TCP三次握手的过程以及为什么需要三次握手</p></li><li><p>以抓包为例，抓包程序在执行的时候实际需要哪些资源</p></li><li><p>[手写代码]向有序数组中插入数</p><p> 完成之后还在此前提上加入了数组有限（虽然坑是我自己挖的）、填充满了需要扩充数组等限制条件</p></li></ol><blockquote><p>一面的时候感觉还是挺轻松的，主要是因为问的问题比较基础，一面面完了之后面试官还带我在食堂吃了一顿饭:)，顺便感叹一下大公司的人真的好多啊</p></blockquote><p>【二面】</p><ol><li><p>进程和线程的区别是什么</p></li><li><p>多线程的优势是什么，为什么需要线程</p></li><li><p>C++的右值引用的应用</p></li><li><p>如何用其他方式实现类似右值引用能够带来的功能</p></li><li><p>析构函数可以是虚函数吗，为什么</p></li><li><p>构造函数可以是虚函数吗，为什么</p></li><li><p>你会如何设计内存分配，可以尽量解决释放内存之后的碎片内存问题</p></li><li><p>假设存在一亿篇文章，如何设计能够根据规定的关键字选出相关的文章并根据相关度排序打分</p><p> 其实这题原本是面试官问我倒排索引的时候，但是我不知道倒排索引，于是就变成了一道这样的场景题，过程就是磕磕盼盼然后面试官一直引导，过程收获还是蛮多的</p></li><li><p>[手写代码]二叉树的非递归中序遍历</p><p> 面试前几天刚在lc上刷过了，很舒服:)</p></li></ol><blockquote><p>二面的时候已经有些吃力了，我感觉很多地方我答得都不好，好几个问题都是面试官不断地引导我才能答出来的，不过还是混到了三面……</p></blockquote><p>【三面】</p><ol><li><p>介绍自己，以及自己的优缺点</p><p> 确实很不擅长这个，感觉以后还是写个模版然后每次说一样的话也比说不出来好:(</p></li><li><p>希望在实习中得到什么，以及对实习有什么要求</p></li><li><p>自己认为与部门中的项目有什么关联（可以具体做些什么）</p></li><li><p>实习时间相关的问题</p></li><li><p>十亿个32bit无序整数集合，求重复出现的整数</p><p> 连着确实却是会出现没有脑子的情况……做这题的时候我已经想不起来1亿=10的多少次方了:(，这题的重点不是算法，而是采用什么结构存储，并且个数的量级会决定采用哪种方式使存储空间最小，主要还是一种看待问题的方式和思路吧，收获还挺多的，比如很多时候不能按直观的想法来，还是需要具体计算或者测试</p></li><li><p>给定一个多边形所有点的坐标，给定一个另外一个点，判断该点在多边形内部还是外部</p><p> 还是只需要给出思路，这题确实一直没有思路:)，面试官提醒了好几次才知道该怎么做，具体就是先解决凸多边形条件下的判断，再尝试解决凹多边形下的判断，不过最后并没有到很细节的地方，基本上只是知道了大概思路。收获就是不要一开始就想着一口吃成个大胖子:)，饭要一口一口吃，问题要一个一个解决:)，大致方向是通过点和中点的连线是否和边相交判断，以及如何判断两条线是否相交来判断点的位置</p></li></ol><blockquote><p>三面的时候事后想想感觉很多时候都没有脑子了，不过自己的思路也出现了问题，还是要多锻炼</p></blockquote><h4 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h4><p>还有一些问题实在记不得了就没贴，整个面试过程中提出的问题很大一部分都是从一开始的问题发散出来的，会在你的回答中找到另外的点进行提问，引导的过程很有意思。</p><p>感觉自己还是欠缺很多解决问题的能力，在面对一个陌生的问题的时候并不能很快地进行系统的分析然后分解成子问题解决，而且感觉架构应该很有意思:)。听最后面试官的语气这次应该是没戏了，打算了解了自己的弱项方面之后，要开始好好学习了，解决一个问题的时候不仅要考虑当前的状况，还要假设别的情况。自己知识的广度和深度，现在哪个都不够:(，以后扩展深度之外尽量扩展广度吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先是在实习僧上投的简历，第一周因为手机问题没有接到电话，第二周才打过去约到了第二天上午十点面试。&lt;/p&gt;
&lt;p&gt;第一次去百度这样的大公司面试，讲真还是很紧张的，提前快一个小时就到地方了，然后因为那地儿实在太堵了，一面的面试官堵在路上了，所以等到十一点多才正式开始面试，结果
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>《编译器设计》读书笔记——中间表示</title>
    <link href="https://mu00.jusot.com/2018/08/08/%E3%80%8A%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA/"/>
    <id>https://mu00.jusot.com/2018/08/08/%E3%80%8A%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2020-08-03T14:44:08.482Z</updated>
    
    <content type="html"><![CDATA[<p>编译器通常组织为一连串的处理趟，随着编译器不断推导有关被编译代码的知识，它必须将这些信息从一趟传递到另一趟，因而，对于推导出有关程序的全部事实，编译器需要一种表示，我们将这种表示称为<strong>中间表示</strong>(intermediate representation)，简称为IR。</p><hr><h3 id="中间表示的分类"><a href="#中间表示的分类" class="headerlink" title="中间表示的分类"></a>中间表示的分类</h3><p>泛泛而言，IR从结构上分为三类：</p><ol><li><strong>图IR</strong>， 将编译器的知识编码在图中。算法通过图中的对象来表述：结点、边、列表、树。</li><li><strong>线性IR</strong>， 类似于某些抽象机上的为代码。相应的算法将迭代遍历简单的线性操作序列。</li><li><strong>混合IR</strong>， 结合了图IR和线性IR的要素，为的是获取两者的优势而避免其弱点。一种常见的混合表示使用底层的线性IR来表示无循环代码的块，使用图来表示这些块之间的控制流。</li></ol><hr><h3 id="图IR"><a href="#图IR" class="headerlink" title="图IR"></a>图IR</h3><p>许多编译器使用的IR将底层的代码表示为图。虽然所有的图IR都包含结点和边，但在抽象层次、图与底层代码之间的关系、图的结构等方面，各种图IR均有所不同。</p><h5 id="与语法相关的树"><a href="#与语法相关的树" class="headerlink" title="与语法相关的树"></a><strong>与语法相关的树</strong></h5><ol><li><p>语法分析树</p><p> 是对输入程序的推导或语法分析的图表示。相对于源程序文本，语法分析树比较大，因为它表示了完整的推导过程，树中的每个结点分别对应于推导过程中的各个语法符号。</p></li><li><p>抽象语法树</p><p> 抽象语法树(Abstract Syntax Tree, AST)保留了语法分析树的基本结构，但剔除了其中非必要的结点。表达式的优先级和语义仍然保持原样，但无关的结点已经消失了。</p></li><li><p>有向非循环图</p><p> 虽然AST与语法树相比更加简洁，但它仍然保留了原来的源代码结构。例如，a<em>2+a</em>2<em>b的AST包含了表达式a</em>2的两个不同副本。有向非循环图(Directed Acyclic Graph, DAG)是AST避免这种复制的一种简写。在DAG中，结点可以有多个父结点，相同子树可以被重用。</p></li></ol><h5 id="图"><a href="#图" class="headerlink" title="图"></a><strong>图</strong></h5><blockquote><p>有向非循环图亦是图的一种。</p></blockquote><ol><li><p>控制流图</p><p> 控制流图(Control-Flow Graph, CFG)对程序中各个基本程序块((具有最大长度的)无分支代码序列，开始于一个有标号的操作，结束于一个分支、跳转或条件判断操作)之间的控制流建立了模型。CFG用一个结点表示每个基本控制块，用一条边表示块之间的每个可能的控制转移。</p></li><li><p>依赖关系图</p><p> 模拟代码片段中值从定义到使用之间流动的图。绘制依赖关系图时边从定义处指向使用处。</p></li><li><p>调用图</p><p> 表示程序中过程间接调用关系的图。调用图用一个结点表示每个过程，用一条边表示每个调用位置。</p></li></ol><hr><h3 id="线性IR"><a href="#线性IR" class="headerlink" title="线性IR"></a>线性IR</h3><p>图IR的备选方案是线性IR，线性IR对操作序列规定了一种清晰且使用的顺序。编译器中已经使用了许多种线性IR，如单地址代码、二地址代码以及三地址代码。</p><ol><li><p><strong>堆栈机代码</strong></p><p> 堆栈机代码是一种单地址代码，假定操作数存在一个栈中。大多数操作从栈获得操作数，并将其结果推入栈。堆栈机代码比较紧凑，栈本身建立了一个隐式的命名空间，从而消除了IR中的许多名字，缩减了IR形式下程序的大小。</p></li><li><p><strong>三地址代码</strong></p><p> 在三地址代码中，大多数操作形如i&lt;-j op k，其中包含一个运算符和两个操作数以及一个结果。一些运算符，如加载立即数或跳转，所需的参数较少。三地址代码相当紧凑，操作和名字都取自有限集。</p></li><li><p><strong>线性代码的表示</strong></p><p> 三地址代码通常实现为一组四元组。每个四元组表示为四个字段：一个运算符、两个操作数（或源）、一个目标。编译器可以用各种方法实现四元组，如简单数组、指针数组、链表等。</p></li><li><p><strong>根据线性代码建立控制流图</strong></p><p> 编译器通常必须在不同IR之间进行转换（通常是不同风格的IR）。一种例行转换是根据线性IR建立CFG。第一步，编译器必须找到线性IR中各个基本程序块的开始和结束。我们将块中的第一个操作称为前导指令(leader)。如果一个操作是过程中的第一个操作，或者它有标号(即可能是某个分支指令的目标)，那么它就是前导指令。如果线性IR包含并非分支指令目标的标号，那么将标号处理为前导指令可能导致块发生不必要的分裂。且如果代码包含任何具有二义性的跳转，那么它无论如何都必须将所有有标号语句处理为前导指令。之后，找到每个基本程序块结尾操作并添加边。</p></li></ol><blockquote><p><strong>具有二义性的跳转</strong>，指分支或跳转指令的目标无法在编译时确定；通常是跳转到寄存器指定的某个地址。</p></blockquote><hr><h3 id="将值映射到名字"><a href="#将值映射到名字" class="headerlink" title="将值映射到名字"></a>将值映射到名字</h3><p>编译器用来为执行期间计算出的各种值分配内部名字的规则，也对它能够产生的代码有所影响。命名方案可能会揭示优化的机会，也可能使优化的机会变得模糊不清。</p><h5 id="临时值的命名"><a href="#临时值的命名" class="headerlink" title="临时值的命名"></a><strong>临时值的命名</strong></h5><p>在底层IR中，各个中间结果都有自身的名字。使用不同的名字会将这些结果暴露给分析和变换的过程。命名可能会隐藏上下文信息，因为其中可能将一个名字用于表示许多不同的值。命名也可能暴露上下文信息，只要它能够在名字和值之间建立对应关系。</p><h5 id="静态单赋值形式"><a href="#静态单赋值形式" class="headerlink" title="静态单赋值形式"></a><strong>静态单赋值形式</strong></h5><p>静态单赋值形式(Static Single-Assignment Form, SSA)是一IR，具有基于值的命名系统，通过重命名和使用称为Φ函数的伪操作产生的。静态单赋值形式中编码了控制的转移和值的流动，它广泛用于优化中。</p><blockquote><p><strong>Φ函数</strong></p><blockquote><p>Φ函数获取几个名字并将其合并，以定义一个新的名字。其行为取决于上下文。它选择其中一个参数的值来定义其目标SSA的名字。</p></blockquote></blockquote><h5 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a><strong>内存模型</strong></h5><p>正如命名临时值的机制会影响到程序的IR版本中能够表示的信息，编译器对每个值的存储位置的选择也有类似的影响。</p><ol><li><p><strong>寄存器到寄存器的模型(Register-to-Register Model)</strong></p><p> 编译器采用激进策略将值保存在寄存器中，而忽略机器的物理寄存器集合规定的任何限制。对任何值来说，如果它在大部分生命周期中可以合法地保存在寄存器中，那么编译器就选择将其置于寄存器中。仅当程序的语义要求将值存储到内存时，编译器才采取相应的操作。</p></li><li><p><strong>内存到内存的模型(Memory-to-Memory Model)</strong></p><p> 编译器假定所有值都保存在内存中。值在临到使用之前，从内存加载到寄存器。在值定义完毕后，即从寄存器写出到内存。</p></li></ol><hr><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>作为转换过程的一部分，编译器需要推导与被转换程序操控的各种实体有关的信息。编译器需要在IR中记录这些信息，或者按需重新推导，别无它法。大多数编译器都选择记录事实而非按需重新推导，这些事实可以直接记录在IR中，备选方案是为这些事实建立一个中央存储库，以提供对相关信息的高效访问能力，这种中央存储库称为符号表，成为了编译器IR不可分割的一部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编译器通常组织为一连串的处理趟，随着编译器不断推导有关被编译代码的知识，它必须将这些信息从一趟传递到另一趟，因而，对于推导出有关程序的全部事实，编译器需要一种表示，我们将这种表示称为&lt;strong&gt;中间表示&lt;/strong&gt;(intermediate representat
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>《编译器设计》读书笔记——上下文相关分析</title>
    <link href="https://mu00.jusot.com/2018/08/07/%E3%80%8A%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90/"/>
    <id>https://mu00.jusot.com/2018/08/07/%E3%80%8A%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90/</id>
    <published>2018-08-06T16:00:00.000Z</published>
    <updated>2020-08-03T14:32:33.755Z</updated>
    
    <content type="html"><![CDATA[<p>将每条语句放到实际的上下文中进行考虑，从而检测类型和约定方面的错误，这种分析一般被称为“上下文相关分析”(context-sensitive analysis)，以区别于语法分析，或者称为”语义推敲”(semantic elaboration)。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>被编译的程序中的某个名字x，在编译器能够为涉及x的计算输出可执行的目标机代码之前，以下问题是须被回答的：</p><ul><li>x中存储了什么种类的值？</li><li>x有多大呢？</li><li>如果x是一个过程，它需要获得哪些参数呢？</li><li>对于x的值来说，其生命周期有多长？</li><li>谁负责分配x的空间(并初始化它)？</li></ul><p>编译器必须根据源语言的规则和源程序，推导出这些问题的答案及其它信息，但这些问题中有许多(如果不是全部)都超出了上下文无关语法，为了解决这些问题，编译器必须深入研究程序的语义，词法分析和语法分析处理的只是程序的形式，而语义分析则进入了<em>上下文相关分析</em>的领域。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>一种抽象范畴，规定了其所有成员共有的性质。常见的类型包括整数，列表和字符串。</p><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>一些类型是程序设计语言预定义的，其他的类型则是程序员构建的。程序设计语言中类型的集合，以及使用类型来规定程序行为的规则，总称为<strong>类型系统</strong>(type system)。</p><h3 id="类型系统的目标"><a href="#类型系统的目标" class="headerlink" title="类型系统的目标"></a>类型系统的目标</h3><p>与上下文无关语法相比，利用类型系统可以在更精确的层次上规定程序的行为。</p><ol><li><p><strong>确保运行时的安全性</strong></p><p> 安全性是使用强类型语言的一个重要原因，如果语言的实现能够保证在程序执行之前捕获大多数类型相关的错误，这将简化程序本身的设计和实现。如果一个语言中每个表达式都能分配一个无歧义的类型，这种语言称为强类型语言。如果每个表达式都可以在编译时确定类型，我们称这种语言为静态类型的(statically typed)，如果某些表达式只能在运行时确定类型，称这种语言为动态类型的(dynamically typed)。还有另两种语言：无类型语言，如汇编代码或BCPL语言；和弱类型语言，及类型系统较为贫乏的语言。</p></li><li><p><strong>提高表达力</strong></p><p> 具有良好结构的类型系统允许语言设计者更精确地规划程序的行为，从而可以加入一些上下文无关语法不可能表示的特性，比如运算符重载(operator overloading)。</p></li><li><p><strong>生成更好的代码</strong></p><p> 设计完善的类型系统为编译器提供了程序中每个表达式的详细信息，通常利用这一信息进行转换可以生成更高校的代码。</p></li><li><p><strong>类型检查</strong></p><p> 为避免运行时类型检查的开销，编译器必须分析程序，为每个名字和表达式分配一种类型。它必须检查这些类型，以确保类型在相应上下文中的使用是合法的。总而言之，这些活动通常称为类型检查，不过这是个误称，它将类型推断和识别类型相关错误的不同活动放在了同一个名称下。</p></li></ol><h3 id="类型系统的组件"><a href="#类型系统的组件" class="headerlink" title="类型系统的组件"></a>类型系统的组件</h3><ol><li><p><strong>基础类型</strong></p><p> 用于表示下述数据种类中的一些或全部：数字，字符和布尔值。几乎所有的语言都包含了一些功能，用于根据其基础类型来构建更复杂的类型。</p></li><li><p><strong>复合类型和构造类型</strong></p><p> 基础类型通常对硬件直接处理的数据提供了足够的抽象，但其通常不足以表示程序所需的信息。为复合或聚合对象构建新类型的能力，是许多程序设计语言的一个基本特性。</p></li><li><p><strong>类型等价性</strong></p><p> 用于判断两种不同类型声明是否等价的机制，一般认为有两种通用的方法，一种是名字等价性(name equivalence, 该规则断言两个类型等价的充分必要条件是二者同名)，另一种是结构等价性(structural equivalence, 该规则断言两个类型等价的充分必要条件是二者有相同的结构)。</p></li><li><p><strong>用于推断的规则</strong></p><p> 一般来说，用于推断类型的规则会对每个运算符规定操作数类型和结果类型之间的映射。类型推断规则可以指出类型错误。</p></li><li><p><strong>推断表达式的类型</strong></p><p> 推断类型的目标是为程序中出现的每个表达式分配一个类型。这要求所有变量都有生命，所有的常量都可以推断出类型，而所有函数的类型信息都是可以获得的。在简单情形下，表达式的类型推断可以从表达式的结构直接承袭而来。</p></li><li><p><strong>类型推断的过程间相关问题</strong></p><p> 表达式的类型推断固有地依赖于形成可执行程序的其他过程。</p></li></ol><h3 id="属性语法框架"><a href="#属性语法框架" class="headerlink" title="属性语法框架"></a>属性语法框架</h3><p><strong>属性语法</strong>(attribute grammar)是用于上下文相关分析的一种形式化机制，也称为<strong>属性化</strong>的上下文无关语法(attributed context-free grammar)。其包含了一个上下文无关语法，外加一组规定了某些计算的规则，每个规则都通过其它属性的值定义了一个值或<strong>属性</strong>。</p><h4 id="综合属性"><a href="#综合属性" class="headerlink" title="综合属性"></a>综合属性</h4><p>完全根据结点本身的属性，其子结点的属性和常量定义的属性</p><h4 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h4><p>完全根据结点本身的属性，其兄弟结点的属性及其父结点的属性(外加常量)定义的属性。</p><h4 id="求值的方法"><a href="#求值的方法" class="headerlink" title="求值的方法"></a>求值的方法</h4><ol><li><p>动态方法</p><p> 这种技术使用特定的属性化语法分析树的结构，来确定求值次序。一种相关的方案是建立属性依赖关系图，对其拓扑排序，使用拓扑次序对属性进行求值。</p></li><li><p>无关方法</p><p> 在这一类方法中，求值的次序与属性语法和特定的属性化语法分析树都是无关的。这种风格的求值方法包括：从左到右重复多趟（直到所有属性的值都确定为止），从右到左重复多趟和从左到右与从右到左交替多趟处理。</p></li><li><p>基于规则的方法</p><p> 依赖于对属性语法的静态分析，来构造出一个求值次序。</p></li></ol><h4 id="环"><a href="#环" class="headerlink" title="环"></a>环</h4><p>有环的属性语法会导致有环的属性依赖关系图，若编译器使用属性语法，那么它必须以适当的方式处理环。</p><h3 id="特设语法制导转换"><a href="#特设语法制导转换" class="headerlink" title="特设语法制导转换"></a>特设语法制导转换</h3><p>在这种方案中，编译器编写者提供在语法分析时需要执行的代码片段。每个片段，即操作都直接关联到语法中的某个产生式。每次语法分析器发现自身处于语法中的特定位置时，都会调用对应的操作，以完成相应的任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;将每条语句放到实际的上下文中进行考虑，从而检测类型和约定方面的错误，这种分析一般被称为“上下文相关分析”(context-sensitive analysis)，以区别于语法分析，或者称为”语义推敲”(semantic elaboration)。&lt;/p&gt;
&lt;h3 id=&quot;概
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
